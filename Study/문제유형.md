### 1. BFS(너비우선탐색)

* 가까운 노드부터 차례로 탐색하는 방식
* 자료구조는 Queue를 사용한다 (FIFO)
* 대표 *문제유형*으로는
  * 최단 경로
  * 레벨 순회 (트리, 네트워크 전파)
  * Flood Fill (영역 탐색, 주로 색칠이나 격자의 특정 영역 탐색)
  * 최소 이동 횟수 제한
* BFS는 최단 경로를 찾을 때 유리하며, 모든 노드를 균등하게 탐색해야 하는 문제에 적합

***

### 2. DFS(깊이우선탐색)

* 먼저 깊이 있는 노드를 끝까지 탐색한 후 되돌아가는 방식
* 자료구조는 Stack을 사용하거나 재귀함수로 구현한다
* 대표 *문제유형* 으로는
  * 모든 경로 탐색
  * 연결 요소 찾기 (그리드에서 연결된 육지 갯수 찾기)
  * Backtracking (N-Queen, 수열에서 특정 조건 만족하는 경로 찾기)
  * Topological Sorintg (위상 정렬)
  * 경로 탐색 (특정 문자열을 만들 수 있는 경로 탐색)
* DFS는 모든 경로를 탐색하거나, 깊이 있는 경로를 먼저 탐색해야 할 때 유리, 재귀문제

***

### 3. DP(다이나믹 프로그래밍, 동적계획법)

* 중복되는 계산을 피하기 위해 이미 계산된 값을 저장하여 다시 사용
* 자료구조는 배열을 사용한다
* 대표 *문제유형* 으로는
  * 피보나치 수열
  * 최단 경로 문제
  * 배낭 문제 (여러 개의 물건이 있을 때, 주어진 배낭의 용량을 초과하지 않으면서 물건을 최대한 가치 있게 담는 방법)
  * 최장 공통 부분 수열 (두 문자열이 주어질 때 가장 긴 공통 부분 수열을 찾는 문제)
  * 최대 부분 수열 합 (연속된 부분 수열의 합이 최대가 되는 값을 찾는 문제)
  * 계단 오르기 문제
  * 동전 거스름돈 문제 (특정 금액을 만들기 위한 최소 동전 수 구하기)
  * 팰린드롬 분할 (문자열을 최소한의 부분으로 나누어 각 부분이 팰린드롬이 되도록 하는 문제)
  * 트리에서의 DP
  * 타일링 문제제
* 최적 부분 구조 (Optimal Substructure): 큰 문제를 작은 문제로 나누었을 때, 작은 문제들의 최적 해답이 큰 문제의 최적 해답을 만들 수 있는 구조.
* 중복되는 하위 문제 (Overlapping Subproblems): 동일한 하위 문제를 여러 번 해결해야 하는 상황이 발생, 이때 DP를 사용해 중복 계산을 피하는 구조.
* DP의 대표적인 문제 접근 방법:
  * Top-Down (재귀 + 메모이제이션): 재귀를 사용해 큰 문제를 작은 문제로 쪼개면서, 이미 계산된 값은 저장해 중복 계산을 피함
  * Bottom-Up (반복문 + 탭보완): 작은 문제부터 차근차근 답을 계산하여 큰 문제를 해결.
* 문제에서 최댓값, 최솟값, 경우의 수 등을 구해야 하고, 중복된 계산을 줄여야 하는 경우
* 배열을 사용해 값을 저장하며, 이전 계산 값을 재사용할 수 있는 문제라면 DP가 적합한 방법

| BFS | DP |
| -------- | -------- |
| 가중치가 없는 그래프에서 최단 경로 탐색에 적합 | 가중치가 있는 문제 또는 최적해를 구할 때 적합 |
| 큐(Queue)를 사용하여 너비 우선 탐색 | 테이블(배열)을 사용하여 작은 문제에서 큰 문제로 확장 |
| 중복 계산이 없음 | 중복 계산을 피하기 위해 메모이제이션 사용 |
| 주로 경로 찾기에 사용 | 최적화 문제(최댓값, 최솟값, 경우의 수)에 사용 |
| 모든 경로의 가중치가 동일할 때 최적 | 경로의 가중치가 달라지는 경우 적합 |
| **예시**: 미로 탐색, 말이동 문제 | **예시**: 다익스트라 알고리즘, 배낭 문제, 피보나치 수열 |

***
